<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>謎検もどき</title>
    
    <!-- 【追加】ファビコン（ブラウザのタブやブックマークのアイコン） -->
    <link rel="icon" href="deco/icon.png" type="image/png">
    <!-- 【追加】スマホのホーム画面に追加したときのアイコン -->
    <link rel="apple-touch-icon" href="deco/icon.png">
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel (JSX Converter) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FontAwesome (Icons) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- YakuHanJP -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/yakuhanjp@3.4.1/dist/css/yakuhanjp.min.css">
    
    <style>
        body { 
            font-family: YakuHanJP, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif;
            user-select: none; 
            touch-action: none; 
            overflow: hidden;
            background-color: #ffffff;
        }

        .font-number {
            font-family: 'Oswald', sans-serif;
            letter-spacing: 0.05em;
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #ffffff; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #888; }
        
        .cursor-pen { cursor: crosshair; }
        .cursor-eraser { cursor: cell; } 

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        /* モバイルでのタップハイライトを無効化 */
        * {
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body class="text-gray-800 w-full overflow-hidden relative">
    
    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, forwardRef, useCallback } = React;

        // --- Constants ---
        const FILE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.jfif', '.gif'];

        // --- Custom Hook: Viewport Height ---
        const useViewportHeight = () => {
            const [height, setHeight] = useState(window.innerHeight);

            useEffect(() => {
                const handleResize = () => {
                    setHeight(window.innerHeight);
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                window.addEventListener('orientationchange', handleResize);
                return () => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('orientationchange', handleResize);
                };
            }, []);

            return height;
        };

        // --- Helper: Circled Numbers ---
        const getCircledNumber = (index) => {
            const circled = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩'];
            return circled[index] || `(${index + 1})`;
        };

        // --- Components ---

        const ConfirmationModal = ({ isOpen, message, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" style={{ touchAction: 'none' }}>
                    <div className="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full border-2 border-red-600 animate-fade-in relative z-50">
                        <h3 className="text-lg font-bold mb-4 text-gray-800">確認</h3>
                        <p className="text-gray-600 mb-6">{message}</p>
                        <div className="flex justify-end space-x-3">
                            <button onClick={onCancel} className="px-4 py-2 border border-gray-300 rounded text-gray-600 hover:bg-gray-100 font-bold">キャンセル</button>
                            <button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 font-bold">OK</button>
                        </div>
                    </div>
                </div>
            );
        };

        const AsyncImage = ({ src, srcs, alt, className, fallback }) => {
            const [loadedSrc, setLoadedSrc] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(false);

            useEffect(() => {
                setLoading(true);
                setError(false);
                setLoadedSrc(null);

                const candidates = srcs || (src ? [src] : []);
                
                if (candidates.length === 0) {
                    setError(true);
                    setLoading(false);
                    return;
                }

                let isMounted = true;
                let attemptIndex = 0;

                const loadNext = () => {
                    if (attemptIndex >= candidates.length) {
                        if (isMounted) {
                            setError(true);
                            setLoading(false);
                        }
                        return;
                    }

                    const img = new Image();
                    const currentCandidate = candidates[attemptIndex];
                    img.src = currentCandidate;
                    
                    img.onload = () => {
                        if (isMounted) {
                            setLoadedSrc(currentCandidate);
                            setLoading(false);
                        }
                    };
                    
                    img.onerror = () => {
                        if (isMounted) {
                            attemptIndex++;
                            loadNext();
                        }
                    };
                };

                loadNext();

                return () => { isMounted = false; };
            }, [src, srcs]);

            if (error) return fallback || <div className="flex flex-col items-center text-gray-400 p-2 justify-center h-full bg-white border"><i className="fas fa-image text-2xl mb-1"></i><span className="text-[10px] mt-1">No Image</span></div>;

            return (
                <div className="relative w-full h-full flex items-center justify-center overflow-hidden bg-white">
                    {loading && <div className="absolute inset-0 flex items-center justify-center bg-gray-50 text-gray-400 font-bold text-xs z-0 font-number">Loading...</div>}
                    <img src={loadedSrc} alt={alt} className={`${className} ${loading ? 'opacity-0' : 'opacity-100'} transition-opacity duration-300`} />
                </div>
            );
        };

        const StartScreen = ({ onStart, initialName }) => {
            const [handleName, setHandleName] = useState(initialName || "");
            const [selectedRiddle, setSelectedRiddle] = useState(1);
            const [riddleInfo, setRiddleInfo] = useState({ creator: '...', count: '...', limit: '...' });

            useEffect(() => {
                const fetchRiddleInfo = async () => {
                    setRiddleInfo({ creator: '読み込み中...', count: '...', limit: '...' });
                    try {
                        const csvPath = `riddle/riddle${selectedRiddle}/riddle${selectedRiddle}.csv`;
                        const response = await fetch(csvPath);
                        if (!response.ok) throw new Error('Not found');
                        const buffer = await response.arrayBuffer();
                        const decoder = new TextDecoder('utf-8');
                        const text = decoder.decode(buffer);
                        const firstLine = text.split(/\r\n|\n/)[0];
                        if (!firstLine) throw new Error('Empty');
                        
                        const [count, , limit, creator] = firstLine.split(',');
                        
                        setRiddleInfo({
                            count: count ? `${count}問` : '不明',
                            limit: limit ? `${limit}分` : '不明',
                            creator: creator ? creator.trim() : '不明'
                        });
                    } catch (e) {
                        setRiddleInfo({ creator: '不明', count: '不明', limit: '不明' });
                    }
                };
                fetchRiddleInfo();
            }, [selectedRiddle]);

            const onNameChange = (e) => {
                let val = e.target.value;
                val = val.replace(/['";\\<>]/g, '');
                setHandleName(val);
            };

            return (
                <div className="h-full overflow-y-auto relative z-20 custom-scrollbar">
                    <div className="flex flex-col items-center justify-center min-h-full p-4">
                        <div className="max-w-4xl w-full bg-white p-6 md:p-8 space-y-6 md:space-y-8 shadow-xl rounded-lg my-auto">
                            <div className="border-b-2 border-red-600 pb-4 mb-4 md:mb-8 flex justify-between items-end">
                                <div className="h-10 md:h-12">
                                    <img src="deco/logo.png" alt="ロゴ" className="h-full object-contain" onError={(e) => e.target.style.display = 'none'} />
                                </div>
                                <div className="text-xs md:text-sm text-gray-500">ユーザーネーム: {handleName || "未入力"}</div>
                            </div>
                            <div className="space-y-4 md:space-y-6">
                                <div className="bg-gray-50 p-4 md:p-6 rounded border border-gray-200">
                                    <label className="block text-gray-700 font-bold mb-2 text-sm md:text-base">ハンドルネーム</label>
                                    <input 
                                        type="text" 
                                        className="w-full border-2 border-gray-300 p-2 md:p-3 rounded focus:outline-none focus:border-red-500 text-base md:text-lg" 
                                        placeholder="ここに入力してください" 
                                        value={handleName} 
                                        onChange={onNameChange}
                                        maxLength={20}
                                    />
                                </div>
                                <div className="bg-gray-50 p-4 md:p-6 rounded border border-gray-200">
                                    <label className="block text-gray-700 font-bold mb-4 text-sm md:text-base">問題セット選択</label>
                                    <div className="grid grid-cols-2 md:grid-cols-5 gap-3 md:gap-4 mb-4">
                                        <button 
                                            onClick={() => setSelectedRiddle(1)}
                                            className={`border-2 font-bold py-2 md:py-3 px-2 md:px-4 rounded shadow-sm font-number transition-colors text-sm md:text-base ${selectedRiddle === 1 ? 'bg-red-600 border-red-600 text-white' : 'bg-red-50 border-red-500 text-red-700'}`}
                                        >
                                            riddle1
                                        </button>
                                        
                                        <button 
                                            onClick={() => setSelectedRiddle(2)}
                                            className={`border-2 font-bold py-2 md:py-3 px-2 md:px-4 rounded shadow-sm font-number transition-colors text-sm md:text-base ${selectedRiddle === 2 ? 'bg-red-600 border-red-600 text-white' : 'bg-red-50 border-red-500 text-red-700'}`}
                                        >
                                            riddle2
                                        </button>

                                        {[3,4,5,6,7,8,9,10].map(num => (
                                            <button key={num} disabled className="bg-gray-200 text-gray-400 font-bold py-2 md:py-3 px-2 md:px-4 rounded cursor-not-allowed font-number text-sm md:text-base">riddle{num}</button>
                                        ))}
                                    </div>
                                    <div className="text-sm md:text-base text-gray-700 bg-white p-3 rounded border border-gray-300 flex flex-wrap gap-4 items-center">
                                        <div className="flex items-center"><i className="fas fa-user-edit text-gray-400 mr-2"></i><span className="font-bold mr-1">制作者:</span> {riddleInfo.creator}</div>
                                        <div className="flex items-center"><i className="fas fa-list-ol text-gray-400 mr-2"></i><span className="font-bold mr-1">問題数:</span> {riddleInfo.count}</div>
                                        <div className="flex items-center"><i className="fas fa-stopwatch text-gray-400 mr-2"></i><span className="font-bold mr-1">制限時間:</span> {riddleInfo.limit}</div>
                                    </div>
                                </div>
                            </div>
                            <div className="flex flex-col items-center justify-center mt-8 md:mt-12 space-y-4">
                                <button 
                                    onClick={() => handleName && onStart(handleName, selectedRiddle)} 
                                    disabled={!handleName} 
                                    className={`font-bold text-lg md:text-xl py-3 md:py-4 px-8 md:px-12 rounded shadow-lg transition-all ${handleName ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-400 text-white cursor-not-allowed'}`}
                                >
                                    模試を受ける
                                </button>
                                <div className="text-xs text-gray-500 text-center leading-relaxed">
                                    <p>・このサイトは本家謎検の挙動とは異なることがあります。</p>
                                    <p>・このサイトはSCRAP、および本家謎検とは一切関係ございません。</p>
                                    <p className="mt-2 text-gray-400">※ページの再読み込みや「戻る」を行うと、進行状況がリセットされます。</p>
                                    <p className="text-gray-400">※推奨環境: Google Chrome / Safari 最新版</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const CanvasLayer = ({ drawings, onDrawEnd, tool, color, isVisible }) => {
            const canvasRef = useRef(null);
            const isDrawing = useRef(false);
            const currentStroke = useRef([]);
            const ctxRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const updateSize = () => {
                    const parent = canvas.parentElement;
                    if(parent) {
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = parent.clientWidth * dpr;
                        canvas.height = parent.clientHeight * dpr;
                        canvas.style.width = `${parent.clientWidth}px`;
                        canvas.style.height = `${parent.clientHeight}px`;
                        const ctx = canvas.getContext('2d');
                        ctx.scale(dpr, dpr);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctxRef.current = ctx;
                        redrawAll();
                    }
                };
                updateSize();
                window.addEventListener('resize', updateSize);
                return () => window.removeEventListener('resize', updateSize);
            }, [drawings]);

            const redrawAll = () => {
                const canvas = canvasRef.current;
                const ctx = ctxRef.current;
                if (!canvas || !ctx) return;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                
                drawings.forEach(stroke => {
                    if (stroke.tool === 'clear') {
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    } else {
                        drawStroke(ctx, stroke);
                    }
                });
            };

            const drawStroke = (ctx, stroke) => {
                if (stroke.points.length < 1) return;
                ctx.beginPath();
                if (stroke.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = 20;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = stroke.color === 'black' ? '#000' : stroke.color === 'red' ? '#ff0000' : '#0000ff';
                }
                if (stroke.tool === 'line' && stroke.points.length > 1) {
                    const start = stroke.points[0];
                    const end = stroke.points[stroke.points.length - 1];
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                } else {
                    ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    for (let i = 1; i < stroke.points.length; i++) {
                        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                    }
                }
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            };

            const drawLive = (e) => {
                const ctx = ctxRef.current;
                const canvas = canvasRef.current;
                if (!ctx || !canvas) return;
                const pos = getPos(e);
                currentStroke.current.push(pos);
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                drawings.forEach(stroke => {
                    if (stroke.tool === 'clear') {
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    } else {
                        drawStroke(ctx, stroke);
                    }
                });
                drawStroke(ctx, { tool, color, points: currentStroke.current });
            };

            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            };

            const handlePointerDown = (e) => {
                if (!isVisible) return;
                e.currentTarget.setPointerCapture(e.pointerId);
                isDrawing.current = true;
                currentStroke.current = [getPos(e)];
                const ctx = ctxRef.current;
                if(ctx) {
                    const pos = getPos(e);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 1, 0, Math.PI * 2);
                    ctx.fillStyle = color === 'black' ? '#000' : color === 'red' ? '#ff0000' : '#0000ff';
                    ctx.fill();
                }
            };

            const handlePointerMove = (e) => {
                if (!isDrawing.current || !isVisible) return;
                drawLive(e);
            };

            const handlePointerUp = (e) => {
                if (!isDrawing.current) return;
                e.currentTarget.releasePointerCapture(e.pointerId);
                isDrawing.current = false;
                if (currentStroke.current.length > 0) {
                    onDrawEnd({ tool, color, points: [...currentStroke.current] });
                }
                currentStroke.current = [];
            };

            useEffect(() => { redrawAll(); }, [drawings, isVisible, tool, color]);

            return (
                <div className={`absolute inset-0 w-full h-full z-10 ${!isVisible ? 'pointer-events-none' : ''}`} style={{ touchAction: 'none' }}>
                    <canvas ref={canvasRef} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} onPointerLeave={handlePointerUp} className={`w-full h-full touch-none ${tool === 'eraser' ? 'cursor-eraser' : 'cursor-pen'}`} />
                </div>
            );
        };

        const ExamScreen = ({ userName, onFinish, config, timeLimit }) => {
            const [currentQIndex, setCurrentQIndex] = useState(0);
            const [answers, setAnswers] = useState({});
            const [lockedAnswers, setLockedAnswers] = useState({});
            const [bookmarks, setBookmarks] = useState({});
            const [timeLeft, setTimeLeft] = useState((timeLimit || 60) * 60);
            const [isMenuOpen, setIsMenuOpen] = useState(false);
            const [drawings, setDrawings] = useState({});
            const [redoStack, setRedoStack] = useState({});
            const [tool, setTool] = useState('pencil');
            const [color, setColor] = useState('black');
            const [isToolbarVisible, setIsToolbarVisible] = useState(true);
            const [modalConfig, setModalConfig] = useState({ isOpen: false, message: '', onConfirm: () => {} });
            const [isTimeUp, setIsTimeUp] = useState(false);
            const itemRefs = useRef({});
            const listContainerRef = useRef(null);
            
            const currentQ = config[currentQIndex];

            useEffect(() => {
                const timer = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            clearInterval(timer);
                            setIsTimeUp(true);
                            return 0;
                        }
                        return prev - 1;
                    });
                }, 1000);
                return () => clearInterval(timer);
            }, []);

            useEffect(() => {
                if (isTimeUp) {
                    const timeout = setTimeout(() => { onFinish(answers); }, 5000);
                    return () => clearTimeout(timeout);
                }
            }, [isTimeUp, answers, onFinish]);

            useEffect(() => {
                const element = itemRefs.current[currentQ.id];
                if (element) element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, [currentQIndex]);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            };

            const handleAnswerChange = (val) => {
                if (lockedAnswers[currentQ.id]) return;
                setAnswers(prev => ({ ...prev, [currentQ.id]: val }));
            };

            const submitAnswer = () => {
                setLockedAnswers(prev => ({ ...prev, [currentQ.id]: true }));
                setTimeout(() => {
                    if (currentQIndex === config.length - 1) {
                        setCurrentQIndex(0);
                    } else {
                        setCurrentQIndex(prev => prev + 1);
                    }
                }, 300);
            };

            const resetAnswer = () => setLockedAnswers(prev => { const next = { ...prev }; delete next[currentQ.id]; return next; });
            const toggleBookmark = (id) => setBookmarks(prev => ({ ...prev, [id]: !prev[id] }));
            const navigate = (direction) => {
                if (direction === 'prev' && currentQIndex > 0) setCurrentQIndex(curr => curr - 1);
                if (direction === 'next' && currentQIndex < config.length - 1) setCurrentQIndex(curr => curr + 1);
            };
            const confirmAction = (message, action) => {
                setModalConfig({ isOpen: true, message, onConfirm: () => { action(); setModalConfig(prev => ({ ...prev, isOpen: false })); } });
            };
            const handleFinish = () => onFinish(answers);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    if (e.key === 'ArrowLeft') navigate('prev');
                    if (e.key === 'ArrowRight') navigate('next');
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentQIndex]);

            const handleDrawEnd = useCallback((newStroke) => {
                setDrawings(prev => {
                    const qDrawings = prev[currentQ.id] || [];
                    return { ...prev, [currentQ.id]: [...qDrawings, newStroke] };
                });
                setRedoStack(prev => { const next = { ...prev }; delete next[currentQ.id]; return next; });
            }, [currentQ.id]);

            const undo = () => {
                const qDrawings = drawings[currentQ.id] || [];
                if (qDrawings.length === 0) return;

                const last = qDrawings[qDrawings.length - 1];
                const remaining = qDrawings.slice(0, -1);

                setDrawings(prev => ({ ...prev, [currentQ.id]: remaining }));
                setRedoStack(prev => ({ 
                    ...prev, 
                    [currentQ.id]: [...(prev[currentQ.id] || []), last] 
                }));
            };

            const redo = () => {
                const qRedos = redoStack[currentQ.id] || [];
                if (qRedos.length === 0) return;

                const toRestore = qRedos[qRedos.length - 1];
                const remaining = qRedos.slice(0, -1);

                setRedoStack(prev => ({ ...prev, [currentQ.id]: remaining }));
                setDrawings(prev => ({ 
                    ...prev, 
                    [currentQ.id]: [...(prev[currentQ.id] || []), toRestore] 
                }));
            };

            const clearAll = () => { 
                const qDrawings = drawings[currentQ.id] || [];
                if (qDrawings.length === 0 || (qDrawings.length > 0 && qDrawings[qDrawings.length - 1].tool === 'clear')) {
                    return;
                }

                const clearStroke = { tool: 'clear', color: 'none', points: [] };
                
                setDrawings(prev => ({ ...prev, [currentQ.id]: [...qDrawings, clearStroke] }));
                setRedoStack(prev => { const next = {...prev}; delete next[currentQ.id]; return next; }); 
            };

            if (isTimeUp) {
                return (
                    <div className="fixed inset-0 z-50 bg-black/90 flex items-center justify-center flex-col text-white animate-fade-in">
                        <h1 className="text-6xl font-bold mb-4 font-number">TIME UP</h1>
                        <p className="text-2xl">終了しました</p>
                        <p className="mt-8 text-gray-400">解答画面へ移動します...</p>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full font-sans relative z-20 overflow-hidden">
                    <ConfirmationModal isOpen={modalConfig.isOpen} message={modalConfig.message} onConfirm={modalConfig.onConfirm} onCancel={() => setModalConfig(prev => ({ ...prev, isOpen: false }))} />
                    
                    {/* Header: 高さ固定。スマホでは高さを少し詰める */}
                    <div className="bg-white border-b border-red-500 h-12 md:h-14 flex items-center justify-between px-2 md:px-4 shrink-0 z-20">
                        <div className="flex items-center space-x-2 md:space-x-4">
                            <div className="h-6 md:h-8"><img src="deco/logo.png" alt="ロゴ" className="h-full object-contain" /></div>
                            <div className="text-xs text-gray-500 hidden md:block">ユーザーネーム: {userName}</div>
                            <button onClick={() => confirmAction('本当に受検を終了しますか？', handleFinish)} className="border border-gray-400 text-gray-700 px-2 py-0.5 md:px-3 md:py-1 text-[10px] md:text-xs hover:bg-gray-100 whitespace-nowrap">受検を終了する &gt;</button>
                        </div>
                        <div className="flex items-end">
                            <span className="text-[10px] md:text-sm text-gray-600 mr-1 mb-1">残り</span>
                            <span className="text-2xl md:text-3xl font-mono text-gray-800 leading-none font-number">{formatTime(timeLeft)}</span>
                        </div>
                    </div>

                    {/* Main Content: Flexで可変 */}
                    <div className="flex flex-1 overflow-hidden relative">
                        {/* Center Area: Image & Canvas */}
                        <div className="flex-1 flex flex-col relative z-0 h-full overflow-hidden">
                            <div className="flex-1 flex items-center justify-center p-2 overflow-hidden relative bg-gray-50/50">
                                <div className="w-full h-full max-w-5xl relative flex items-center justify-center">
                                    {currentQIndex > 0 && <button onClick={() => navigate('prev')} className="absolute left-0 top-1/2 -translate-y-1/2 z-30 bg-white/50 hover:bg-white rounded-full p-1 md:p-2 text-gray-600 shadow-lg transform -translate-x-1/2 md:translate-x-0 w-12 h-12 md:w-16 md:h-16 flex items-center justify-center"><i className="fas fa-chevron-left text-2xl md:text-3xl"></i><div className="absolute -bottom-4 text-[10px] md:text-xs text-center font-number bg-white/80 px-1 rounded">{String(currentQIndex).padStart(2,'0')}</div></button>}
                                    {currentQIndex < config.length - 1 && <button onClick={() => navigate('next')} className="absolute right-0 top-1/2 -translate-y-1/2 z-30 bg-white/50 hover:bg-white rounded-full p-1 md:p-2 text-gray-600 shadow-lg transform translate-x-1/2 md:translate-x-0 w-12 h-12 md:w-16 md:h-16 flex items-center justify-center"><i className="fas fa-chevron-right text-2xl md:text-3xl"></i><div className="absolute -bottom-4 text-[10px] md:text-xs text-center font-number bg-white/80 px-1 rounded">{String(currentQIndex + 2).padStart(2,'0')}</div></button>}
                                    
                                    <div className="relative w-full h-full select-none flex items-center justify-center bg-white shadow-lg border border-gray-200">
                                        <AsyncImage srcs={currentQ.imageSrcs} alt={`Problem ${currentQ.id}`} className="max-w-full max-h-full object-contain pointer-events-none" fallback={<div className="absolute inset-0 w-full h-full bg-gray-50 flex-col items-center justify-center text-gray-400 border-2 border-dashed border-gray-300 flex"><i className="fas fa-image text-4xl mb-2"></i><span className="text-xl font-bold text-gray-500">問題 {currentQ.id}</span><span className="text-xs mt-2">画像を配置してください</span></div>} />
                                        <div className="absolute inset-0 w-full h-full"><CanvasLayer drawings={drawings[currentQ.id] || []} onDrawEnd={handleDrawEnd} tool={tool} color={color} isVisible={isToolbarVisible} /></div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Footer (Answer Area): 高さ自動調節 */}
                            <div className="bg-white border-t border-gray-300 p-2 shrink-0 z-20 shadow-[0_-2px_10px_rgba(0,0,0,0.1)]">
                                {/* Toolbar Line */}
                                <div className="flex justify-center items-center mb-2 bg-gray-100 py-1 px-2 rounded-lg inline-block mx-auto min-w-max max-w-full overflow-x-auto custom-scrollbar">
                                    <button onClick={() => setIsToolbarVisible(!isToolbarVisible)} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200 ${isToolbarVisible ? 'text-red-600' : ''}`}><i className={`fas ${isToolbarVisible ? 'fa-eye' : 'fa-eye-slash'} text-sm md:text-lg`}></i></button>
                                    <div className={`flex items-center space-x-1 md:space-x-2 ${isToolbarVisible ? '' : 'invisible pointer-events-none'}`}>
                                        <div className="w-px h-5 md:h-6 bg-gray-300 mx-1"></div>
                                        <button onClick={() => setTool('pencil')} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border ${tool==='pencil' ? 'border-red-500 bg-red-50 text-red-600' : 'border-transparent text-gray-600 hover:bg-gray-200'}`}><i className="fas fa-pencil-alt text-sm md:text-lg"></i></button>
                                        <button onClick={() => setTool('line')} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border ${tool==='line' ? 'border-red-500 bg-red-50 text-red-600' : 'border-transparent text-gray-600 hover:bg-gray-200'}`}><i className="fas fa-slash text-sm md:text-lg"></i></button>
                                        <button onClick={() => setTool('eraser')} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border ${tool==='eraser' ? 'border-red-500 bg-red-50 text-red-600' : 'border-transparent text-gray-600 hover:bg-gray-200'}`}><i className="fas fa-eraser text-sm md:text-lg"></i></button>
                                        <div className="w-px h-5 md:h-6 bg-gray-300 mx-1"></div>
                                        <button onClick={() => setColor('black')} className={`w-6 h-6 md:w-8 md:h-8 rounded-full border-2 mx-0.5 md:mx-1 flex items-center justify-center ${color==='black' ? 'border-red-500 scale-110' : 'border-transparent opacity-70 hover:opacity-100'}`}><div className="w-full h-full rounded-full border border-gray-300 bg-black"></div></button>
                                        <button onClick={() => setColor('red')} className={`w-6 h-6 md:w-8 md:h-8 rounded-full border-2 mx-0.5 md:mx-1 flex items-center justify-center ${color==='red' ? 'border-red-500 scale-110' : 'border-transparent opacity-70 hover:opacity-100'}`}><div className="w-full h-full rounded-full border border-gray-300 bg-red-600"></div></button>
                                        <button onClick={() => setColor('blue')} className={`w-6 h-6 md:w-8 md:h-8 rounded-full border-2 mx-0.5 md:mx-1 flex items-center justify-center ${color==='blue' ? 'border-red-500 scale-110' : 'border-transparent opacity-70 hover:opacity-100'}`}><div className="w-full h-full rounded-full border border-gray-300 bg-blue-600"></div></button>
                                        <div className="w-px h-5 md:h-6 bg-gray-300 mx-1"></div>
                                        <button onClick={undo} className="w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200"><i className="fas fa-undo text-sm md:text-lg"></i></button>
                                        <button onClick={redo} className="w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200"><i className="fas fa-redo text-sm md:text-lg"></i></button>
                                        <button onClick={clearAll} className="w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200"><i className="fas fa-trash-alt text-sm md:text-lg"></i></button>
                                    </div>
                                </div>
                                
                                {/* Answer Line: スマホではフレックス折り返しを許容しレイアウトを調整 */}
                                <div className="flex flex-row items-stretch space-x-2 max-w-4xl mx-auto h-12 md:h-14">
                                    <button onClick={() => toggleBookmark(currentQ.id)} className={`flex flex-col items-center justify-center px-1 md:p-2 w-10 md:w-14 shrink-0 ${bookmarks[currentQ.id] ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} transition-colors rounded-sm`}>
                                        <div className="text-[8px] md:text-[9px] mb-0.5 whitespace-nowrap">後で確認</div>
                                        <i className={`fas fa-bookmark text-sm md:text-xl ${bookmarks[currentQ.id] ? 'text-white' : 'text-gray-400'}`}></i>
                                    </button>
                                    
                                    <div className="flex-1 border-2 border-black flex items-center px-2 md:px-4 relative bg-gray-100 overflow-hidden">
                                        {currentQ.type === 'text' ? (
                                            <input type="text" placeholder={lockedAnswers[currentQ.id] ? "" : "解答入力"} value={answers[currentQ.id] || ""} onChange={(e) => handleAnswerChange(e.target.value)} disabled={lockedAnswers[currentQ.id]} className="w-full h-full bg-transparent text-lg md:text-xl outline-none disabled:text-gray-500" />
                                        ) : (
                                            <div className="flex space-x-2 md:space-x-4 w-full h-full items-center overflow-x-auto no-scrollbar">
                                                {currentQ.options.map((opt, idx) => (
                                                    <button key={idx} disabled={lockedAnswers[currentQ.id]} onClick={() => handleAnswerChange(idx)} className={`flex items-center space-x-1 px-1.5 py-1 rounded whitespace-nowrap ${answers[currentQ.id] === idx ? 'text-red-600 font-bold' : 'text-gray-600'}`}>
                                                        <span className={`w-3 h-3 md:w-4 md:h-4 rounded-full border flex-shrink-0 ${answers[currentQ.id] === idx ? 'bg-red-600 border-red-600' : 'border-gray-400'}`}></span>
                                                        <span className="text-sm md:text-base">{getCircledNumber(idx)} {opt}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    
                                    <div className="w-20 md:w-32 shrink-0">
                                        {lockedAnswers[currentQ.id] ? (
                                            <button onClick={resetAnswer} className="w-full h-full border-2 border-red-600 text-red-600 font-bold hover:bg-red-50 text-sm md:text-lg">リセット</button>
                                        ) : (
                                            <button onClick={submitAnswer} className="w-full h-full border-2 border-red-800 text-red-800 font-bold bg-white hover:bg-red-50 text-sm md:text-lg shadow-sm">解答</button>
                                        )}
                                    </div>
                                </div>
                                <div className="md:hidden mt-1 text-center">
                                    <button onClick={() => setIsMenuOpen(true)} className="text-[10px] font-bold flex items-center justify-center w-full py-1 bg-white border shadow-sm text-gray-500"><i className="fas fa-list-ol mr-1"></i> 問題一覧を見る</button>
                                </div>
                            </div>
                        </div>

                        {/* Sidebar (Desktop only) */}
                        <div className="hidden md:flex w-64 bg-white border-l border-gray-300 flex-col shrink-0 overflow-hidden h-full">
                            <div ref={listContainerRef} className="flex-1 overflow-y-auto custom-scrollbar pb-20">
                                {config.map((q, idx) => (
                                    <QuestionListItem key={q.id} ref={(el) => itemRefs.current[q.id] = el} q={q} isActive={currentQIndex === idx} isAnswered={!!lockedAnswers[q.id]} isBookmarked={!!bookmarks[q.id]} userAnswer={answers[q.id]} onClick={() => setCurrentQIndex(idx)} />
                                ))}
                            </div>
                        </div>
                    </div>
                    
                    {/* Mobile Menu Modal */}
                    {isMenuOpen && (
                        <div className="fixed inset-0 z-50 bg-gray-800/80 flex items-center justify-center p-4">
                            <div className="bg-white w-full h-full max-w-md rounded-lg overflow-hidden flex flex-col relative">
                                <div className="p-4 border-b flex justify-between items-center bg-gray-100">
                                    <span className="font-bold">問題一覧</span>
                                    <button onClick={() => setIsMenuOpen(false)}><i className="fas fa-times text-2xl text-gray-600"></i></button>
                                </div>
                                <div className="flex-1 overflow-y-auto p-2">
                                    {config.map((q, idx) => (
                                        <QuestionListItem key={q.id} q={q} isActive={currentQIndex === idx} isAnswered={!!lockedAnswers[q.id]} isBookmarked={!!bookmarks[q.id]} userAnswer={answers[q.id]} onClick={() => { setCurrentQIndex(idx); setIsMenuOpen(false); }} />
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const FinishScreen = ({ userAnswers, onRestart, config, riddleId }) => {
            const [explanationImageSrcs, setExplanationImageSrcs] = useState(null);
            const results = useMemo(() => {
                let totalScore = 0;
                const grading = config.map(q => {
                    const userAns = userAnswers[q.id];
                    let isCorrect = false;
                    let displayUserAns = "-";
                    let displayCorrectAns = "-";
                    
                    if (q.type === 'choice') {
                        if (userAns !== undefined) {
                            displayUserAns = `${getCircledNumber(userAns)}${q.options[userAns]}`;
                        } else {
                            displayUserAns = "未回答";
                        }
                        const correctStr = q.primaryAnswer || ""; 
                        const hasCircle = /^[\u2460-\u2469]/.test(correctStr);
                        if (hasCircle) {
                            displayCorrectAns = correctStr;
                        } else {
                            const correctIndex = q.options.findIndex(opt => opt === correctStr);
                            if (correctIndex !== -1) {
                                displayCorrectAns = `${getCircledNumber(correctIndex)}${q.options[correctIndex]}`;
                            } else {
                                displayCorrectAns = correctStr;
                            }
                        }
                        const userAnsText = userAns !== undefined ? q.options[userAns] : "";
                        const userAnsFull = userAns !== undefined ? `${getCircledNumber(userAns)}${q.options[userAns]}` : "";
                        isCorrect = q.correctAnswerList.some(ans => ans === userAnsText || ans === userAnsFull);
                    } else {
                        displayUserAns = userAns || "未回答";
                        displayCorrectAns = q.primaryAnswer || "";
                        isCorrect = q.correctAnswerList.includes(userAns);
                    }

                    if (isCorrect) totalScore += q.points;
                    return { id: q.id, userAns: displayUserAns, correctAns: displayCorrectAns, isCorrect, explanationSrcs: q.explanationSrcs };
                });
                return { grading, totalScore };
            }, [userAnswers, config]);

            const shareOnX = () => {
                const text = `riddle${riddleId}で${results.totalScore}点を獲得しました！\nあなたも謎を解いてみよう\nhttps://maruten0420.github.io/Nazoken-Modoki/`;
                const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
                window.open(url, '_blank');
            };

            return (
                <div className="flex flex-col h-full font-sans overflow-hidden relative z-20">
                     <div className="border-b-2 border-red-600 p-4 flex justify-between items-center bg-white shrink-0">
                        <h1 className="text-xl md:text-2xl font-bold text-red-600">受検結果</h1>
                        <div className="text-lg md:text-xl font-bold">合計得点: <span className="text-2xl md:text-3xl text-red-600 font-number">{results.totalScore}</span> / 100点</div>
                    </div>
                    <div className="flex-1 overflow-y-auto p-2 md:p-8">
                        <div className="max-w-5xl mx-auto bg-white shadow rounded-lg overflow-hidden">
                            <table className="w-full text-left border-collapse text-sm md:text-base">
                                <thead className="bg-gray-100 border-b border-gray-300">
                                    <tr>
                                        <th className="p-2 md:p-3 text-center w-10 md:w-16">No.</th>
                                        <th className="p-2 md:p-3 w-1/4">正解</th>
                                        <th className="p-2 md:p-3 w-1/4">あなたの答え</th>
                                        <th className="p-2 md:p-3 text-center w-10 md:w-16">判定</th>
                                        <th className="p-2 md:p-3 text-center w-16 md:w-24">解説</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {results.grading.map((row) => (
                                        <tr key={row.id} className="border-b border-gray-200 hover:bg-gray-50">
                                            <td className="p-2 md:p-3 text-center font-bold text-gray-700 font-number">{row.id}</td>
                                            <td className="p-2 md:p-3 text-green-700 font-medium break-all">{row.correctAns}</td>
                                            <td className="p-2 md:p-3 text-gray-800 break-all">{row.userAns}</td>
                                            <td className="p-2 md:p-3 text-center">
                                                {row.isCorrect ? <i className="fas fa-check-circle text-green-500 text-xl md:text-2xl"></i> : <i className="fas fa-times-circle text-red-500 text-xl md:text-2xl"></i>}
                                            </td>
                                            <td className="p-2 md:p-3 text-center">
                                                <button onClick={() => setExplanationImageSrcs(row.explanationSrcs)} className="text-gray-600 hover:text-red-600 transition-colors flex items-center justify-center w-full">
                                                    <i className="fas fa-book-open mr-1"></i> <span className="hidden sm:inline">解説</span>
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="flex flex-col items-center justify-center mt-8 pb-8 space-y-4">
                             <button onClick={onRestart} className="bg-red-600 text-white font-bold text-lg py-4 px-12 hover:bg-red-700 shadow-lg transition-transform hover:scale-105">トップページに戻る</button>
                             <button onClick={shareOnX} className="bg-black text-white font-bold text-lg py-3 px-10 rounded-full hover:bg-gray-800 shadow-lg transition-transform hover:scale-105 flex items-center">
                                {/* 修正: 文字 'X' をユニコードの '𝕏' に変更 */}
                                <i className="fab fa-x-twitter mr-2 text-xl"></i> 𝕏で結果報告！
                             </button>
                        </div>
                    </div>
                    {explanationImageSrcs && (
                        <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4 animate-fade-in cursor-pointer" onClick={() => setExplanationImageSrcs(null)}>
                            <div className="relative max-w-4xl max-h-full bg-white p-1 rounded shadow-xl cursor-default" onClick={e => e.stopPropagation()}>
                                <button onClick={() => setExplanationImageSrcs(null)} className="absolute -top-10 right-0 text-white hover:text-gray-300"><i className="fas fa-times text-3xl"></i></button>
                                <div className="overflow-auto max-h-[85vh]">
                                    <AsyncImage srcs={explanationImageSrcs} alt="解説" className="max-w-full h-auto" fallback={<div className="p-8 text-center text-gray-500"><p>解説画像が見つかりませんでした。</p></div>} />
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const QuestionListItem = forwardRef(({ q, isActive, isAnswered, isBookmarked, userAnswer, onClick }, ref) => {
            let answerText = "";
            if (isAnswered) {
                if (q.type === 'choice' && userAnswer !== undefined) {
                    answerText = `${getCircledNumber(userAnswer)}${q.options[userAnswer]}`; 
                } else if (userAnswer) {
                    answerText = userAnswer;
                }
            }
            const bgClass = isActive ? 'bg-red-50' : (isAnswered ? 'bg-gray-200' : 'bg-white');
            const textClass = isAnswered ? 'text-gray-600' : 'text-gray-800';

            return (
                <button ref={ref} onClick={onClick} className={`w-full border-b border-gray-200 flex items-stretch text-left h-20 transition-colors ${bgClass} ${textClass}`}>
                    <div className={`w-1 shrink-0 ${isActive ? 'bg-red-600' : isBookmarked ? 'bg-red-500' : 'bg-transparent'}`}></div>
                    
                    <div className="flex-1 p-2 relative overflow-hidden h-full grid grid-cols-[1fr_auto] grid-rows-2 gap-x-2">
                        {/* 上段左: 番号と点数 */}
                        <div className="flex items-center space-x-2 col-start-1 row-start-1 self-start">
                            <span className={`text-2xl font-bold leading-none font-number ${isActive ? 'text-red-600' : isAnswered ? 'text-gray-600' : 'text-gray-800'}`}>{String(q.id).padStart(2, '0')}</span>
                            <span className="text-xs text-gray-400">{q.points}点</span>
                        </div>

                        {/* 右側全体: 画像 (Rowspan 2) */}
                        <div className="col-start-2 row-start-1 row-end-3 w-16 h-full bg-white border border-gray-200 flex items-center justify-center overflow-hidden self-center">
                             <AsyncImage srcs={q.imageSrcs} className="w-full h-full object-cover" />
                        </div>

                        {/* 下段左: しおりと解答 (gapで重なり回避) */}
                        <div className="col-start-1 row-start-2 flex items-end self-end h-full relative w-full overflow-hidden">
                            <div className="flex items-center w-full gap-2">
                                {isBookmarked && <div className="text-red-600 flex-shrink-0"><i className="fas fa-bookmark text-xl"></i></div>}
                                {isAnswered && <span className="text-sm font-bold truncate flex-1 min-w-0 text-left">{answerText}</span>}
                            </div>
                        </div>
                    </div>
                </button>
            );
        });

        // 3. Appコンポーネントの修正（CSV読み込み処理）
        const App = () => {
            const [screen, setScreen] = useState('start');
            const [userName, setUserName] = useState("");
            const [finalAnswers, setFinalAnswers] = useState({});
            const [config, setConfig] = useState([]);
            const [loading, setLoading] = useState(false);
            const viewportHeight = useViewportHeight();
            
            // 【修正4】 制限時間管理用の state を追加
            const [timeLimit, setTimeLimit] = useState(60);
            
            // 【修正8】 現在の問題セットIDを管理
            const [currentRiddleId, setCurrentRiddleId] = useState(1);

            // Function to load config for a specific riddle
            const loadRiddleData = async (riddleId) => {
                setLoading(true);
                try {
                    const csvPath = `riddle/riddle${riddleId}/riddle${riddleId}.csv`;
                    const response = await fetch(csvPath);
                    if (!response.ok) throw new Error('CSV not found');
                    const buffer = await response.arrayBuffer();
                    const decoder = new TextDecoder('utf-8');
                    const text = decoder.decode(buffer);
                    
                    const lines = text.split(/\r\n|\n/).filter(line => line.trim() !== '');
                    if (lines.length < 1) throw new Error('Empty CSV');

                    // 【修正5】 1行目3列目から制限時間を取得するように変更
                    const [totalStr, selCountStr, timeLimitStr] = lines[0].split(',');
                    const totalQuestions = parseInt(totalStr, 10);
                    const selectionCount = parseInt(selCountStr, 10);

                    // 【修正6】 取得した制限時間を state にセット（数値変換、不正値なら60分）
                    const parsedLimit = parseInt(timeLimitStr, 10);
                    setTimeLimit(!isNaN(parsedLimit) && parsedLimit > 0 ? parsedLimit : 60);

                    const selectionMap = {};
                    for (let i = 1; i <= selectionCount; i++) {
                        const cols = lines[i].split(',');
                        const qId = parseInt(cols[0], 10);
                        const options = cols.slice(1).filter(opt => opt && opt.trim() !== '');
                        selectionMap[qId] = options;
                    }

                    const tempConfig = [];
                    const startAnswerLine = selectionCount + 1;
                    
                    for (let i = 0; i < totalQuestions; i++) {
                        const lineIdx = startAnswerLine + i;
                        if (lineIdx >= lines.length) break;
                        
                        const cols = lines[lineIdx].split(',');
                        const points = parseInt(cols[0], 10) || 0;
                        const validAnswers = cols.slice(1).filter(a => a && a.trim() !== '');
                        const primaryAnswer = cols[1] ? cols[1].trim() : ""; 
                        
                        const qId = i + 1;
                        const isSelection = !!selectionMap[qId];

                        const qNum = String(qId).padStart(2, '0');
                        const imgBase = `riddle/riddle${riddleId}/riddle${riddleId}_${qNum}`;
                        const ansBase = `riddle/riddle${riddleId}/answer_${qNum}`;
                        
                        const imageSrcs = FILE_EXTENSIONS.map(ext => imgBase + ext);
                        const explanationSrcs = FILE_EXTENSIONS.map(ext => ansBase + ext);
                        
                        tempConfig.push({
                            id: qId,
                            imageSrcs: imageSrcs,
                            explanationSrcs: explanationSrcs,
                            points: points,
                            type: isSelection ? 'choice' : 'text',
                            options: selectionMap[qId] || [],
                            correctAnswerList: validAnswers,
                            primaryAnswer: primaryAnswer
                        });
                    }
                    
                    setConfig(tempConfig);
                    setScreen('exam'); 
                } catch (e) {
                    console.error("CSV Load Error:", e);
                    alert(`データの読み込みに失敗しました。\n${e.message}`);
                } finally {
                    setLoading(false);
                }
            };

            const startExam = (name, riddleId) => {
                setUserName(name);
                setCurrentRiddleId(riddleId); // RiddleIDを保存
                loadRiddleData(riddleId);
            };

            const finishExam = (answers) => { setFinalAnswers(answers); setScreen('finish'); };
            const restart = () => { setFinalAnswers({}); setScreen('start'); };

            if (loading) {
                return <div className="w-full flex items-center justify-center bg-white font-sans" style={{ height: viewportHeight }}>設定データを読み込み中...</div>;
            }

            return (
                <div 
                    className="w-full font-sans border-[4px] md:border-[8px] border-red-600 box-border overflow-hidden relative"
                    style={{ height: viewportHeight }} // 正確な高さを適用
                >
                    {/* Fixed Background Layer */}
                    <div style={{ position: 'absolute', inset: 0, zIndex: -1, backgroundImage: "url('deco/back.png')", backgroundRepeat: 'repeat', backgroundPosition: 'center', opacity: 0.5 }}></div>

                    {screen === 'start' && <StartScreen onStart={startExam} initialName={userName} />}
                    
                    {/* 【修正7】 ExamScreen に timeLimit を渡す */}
                    {screen === 'exam' && <ExamScreen userName={userName} onFinish={finishExam} config={config} timeLimit={timeLimit} />}
                    
                    {screen === 'finish' && <FinishScreen userAnswers={finalAnswers} onRestart={restart} config={config} riddleId={currentRiddleId} />}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
