<!DOCTYPE html> 
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>謎解き模擬試験</title>
    
    <link rel="icon" href="deco/icon.png" type="image/png">
    <link rel="apple-touch-icon" href="deco/icon.png">
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/yakuhanjp@3.4.1/dist/css/yakuhanjp.min.css">
    
    <style>
        body { 
            font-family: YakuHanJP, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif;
            user-select: none; 
            touch-action: none; 
            overflow: hidden;
            background-color: #ffffff;
        }
        .font-number { font-family: 'Oswald', sans-serif; letter-spacing: 0.05em; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #ffffff; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #888; }
        .cursor-pen { cursor: crosshair; }
        .cursor-eraser { cursor: cell; } 
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
        * { -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body class="text-gray-800 w-full overflow-hidden relative">
    
    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, forwardRef, useCallback } = React;

        // --- Constants ---
        const FILE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.jfif', '.gif'];
        const MAX_RIDDLE_CHECK = 20;

        // --- Custom Hook ---
        const useViewportHeight = () => {
            const [height, setHeight] = useState(window.innerHeight);
            useEffect(() => {
                const handleResize = () => setHeight(window.innerHeight);
                window.addEventListener('resize', handleResize);
                window.addEventListener('orientationchange', handleResize);
                return () => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('orientationchange', handleResize);
                };
            }, []);
            return height;
        };

        const getCircledNumber = (index) => {
            const circled = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩'];
            return circled[index] || `(${index + 1})`;
        };

        const resolveImage = (srcs) => {
            return new Promise((resolve) => {
                let attempt = 0;
                const tryNext = () => {
                    if (attempt >= srcs.length) {
                        resolve(null);
                        return;
                    }
                    const img = new Image();
                    img.src = srcs[attempt];
                    img.onload = () => resolve(srcs[attempt]);
                    img.onerror = () => {
                        attempt++;
                        tryNext();
                    };
                };
                tryNext();
            });
        };

        // --- UI Components ---

        const ConfirmationModal = ({ isOpen, message, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4" style={{ touchAction: 'none' }}>
                    <div className="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full border-2 border-red-600 animate-fade-in relative z-50">
                        <h3 className="text-lg font-bold mb-4 text-gray-800">確認</h3>
                        <p className="text-gray-600 mb-6">{message}</p>
                        <div className="flex justify-end space-x-3">
                            <button onClick={onCancel} className="px-4 py-2 border border-gray-300 rounded text-gray-600 hover:bg-gray-100 font-bold">キャンセル</button>
                            <button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 font-bold">OK</button>
                        </div>
                    </div>
                </div>
            );
        };

        // AsyncImage: modeプロパティを追加 ('fit' or 'scroll')
        const AsyncImage = ({ src, srcs, alt, className, fallback, mode = 'fit' }) => {
            const [loadedSrc, setLoadedSrc] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(false);

            useEffect(() => {
                setLoading(true);
                setError(false);
                setLoadedSrc(null);
                const candidates = srcs || (src ? [src] : []);
                if (candidates.length === 0) {
                    setError(true);
                    setLoading(false);
                    return;
                }
                let isMounted = true;
                let attemptIndex = 0;
                const loadNext = () => {
                    if (attemptIndex >= candidates.length) {
                        if (isMounted) { setError(true); setLoading(false); }
                        return;
                    }
                    const img = new Image();
                    const currentCandidate = candidates[attemptIndex];
                    img.src = currentCandidate;
                    img.onload = () => { if (isMounted) { setLoadedSrc(currentCandidate); setLoading(false); } };
                    img.onerror = () => { if (isMounted) { attemptIndex++; loadNext(); } };
                };
                loadNext();
                return () => { isMounted = false; };
            }, [src, srcs]);

            if (error) return fallback || <div className="flex flex-col items-center text-gray-400 p-2 justify-center h-full bg-white border"><i className="fas fa-image text-2xl mb-1"></i><span className="text-[10px] mt-1">No Image</span></div>;

            // modeによってラッパーのクラスを切り替え
            const wrapperClass = mode === 'fit'
                ? "relative w-full h-full flex items-center justify-center overflow-hidden bg-white"
                : "relative w-full min-h-[100px] flex items-center justify-center bg-white"; 

            return (
                <div className={wrapperClass}>
                    {loading && <div className="absolute inset-0 flex items-center justify-center bg-gray-50 text-gray-400 font-bold text-xs z-0 font-number">Loading...</div>}
                    <img src={loadedSrc} alt={alt} className={`${className} ${loading ? 'opacity-0' : 'opacity-100'} transition-opacity duration-300`} />
                </div>
            );
        };

        const CanvasLayer = ({ drawings = [], onDrawEnd, tool, color, isVisible }) => {
            const canvasRef = useRef(null);
            const isDrawing = useRef(false);
            const currentStroke = useRef([]);
            const ctxRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const updateSize = () => {
                    const parent = canvas.parentElement;
                    if(parent) {
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = parent.clientWidth * dpr;
                        canvas.height = parent.clientHeight * dpr;
                        canvas.style.width = `${parent.clientWidth}px`;
                        canvas.style.height = `${parent.clientHeight}px`;
                        const ctx = canvas.getContext('2d');
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctxRef.current = ctx;
                        redrawAll();
                    }
                };
                updateSize();
                window.addEventListener('resize', updateSize);
                return () => window.removeEventListener('resize', updateSize);
            }, [drawings]);

            const redrawAll = () => {
                const canvas = canvasRef.current;
                const ctx = ctxRef.current;
                if (!canvas || !ctx) return;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                if (!Array.isArray(drawings)) return;
                drawings.forEach(stroke => {
                    if (stroke.tool === 'clear') {
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    } else {
                        drawStroke(ctx, stroke);
                    }
                });
            };

            const drawStroke = (ctx, stroke) => {
                if (!stroke.points || stroke.points.length < 1) return;
                ctx.beginPath();
                if (stroke.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = 20;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = stroke.color === 'black' ? '#000' : stroke.color === 'red' ? '#ff0000' : '#0000ff';
                }
                if (stroke.tool === 'line' && stroke.points.length > 1) {
                    const start = stroke.points[0];
                    const end = stroke.points[stroke.points.length - 1];
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                } else {
                    ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    for (let i = 1; i < stroke.points.length; i++) {
                        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                    }
                }
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            };

            const drawLive = (e) => {
                const ctx = ctxRef.current;
                const canvas = canvasRef.current;
                if (!ctx || !canvas) return;
                const pos = getPos(e);
                currentStroke.current.push(pos);
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                if (Array.isArray(drawings)) {
                    drawings.forEach(stroke => {
                        if (stroke.tool === 'clear') {
                            ctx.save();
                            ctx.setTransform(1, 0, 0, 1, 0, 0);
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.restore();
                        } else {
                            drawStroke(ctx, stroke);
                        }
                    });
                }
                drawStroke(ctx, { tool, color, points: currentStroke.current });
            };

            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            };

            const handlePointerDown = (e) => {
                if (!isVisible) return;
                try { e.currentTarget.setPointerCapture && e.currentTarget.setPointerCapture(e.pointerId); } catch {}
                isDrawing.current = true;
                currentStroke.current = [getPos(e)];
                const ctx = ctxRef.current;
                if(ctx) {
                    const pos = getPos(e);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 1, 0, Math.PI * 2);
                    ctx.fillStyle = color === 'black' ? '#000' : color === 'red' ? '#ff0000' : '#0000ff';
                    ctx.fill();
                }
            };

            const handlePointerMove = (e) => { if (!isDrawing.current || !isVisible) return; drawLive(e); };
            
            const handlePointerUp = (e) => {
                if (!isDrawing.current) return;
                try { e.currentTarget.releasePointerCapture && e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
                isDrawing.current = false;
                if (currentStroke.current.length > 0) {
                    onDrawEnd({ tool, color, points: [...currentStroke.current] });
                }
                currentStroke.current = [];
            };

            useEffect(() => { redrawAll(); }, [drawings, isVisible, tool, color]);

            return (
                <div className={`absolute inset-0 w-full h-full z-10 ${!isVisible ? 'pointer-events-none' : ''}`} style={{ touchAction: 'none' }}>
                    <canvas ref={canvasRef} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} onPointerLeave={handlePointerUp} className={`w-full h-full touch-none ${tool === 'eraser' ? 'cursor-eraser' : 'cursor-pen'}`} />
                </div>
            );
        };

        const QuestionListItem = forwardRef(({ q, isActive, isAnswered, isBookmarked, userAnswer, onClick }, ref) => {
            let answerText = "";
            if (isAnswered) {
                if (q.type === 'choice' && userAnswer !== undefined) {
                    answerText = `${getCircledNumber(userAnswer)}${q.options[userAnswer]}`; 
                } else if (userAnswer) {
                    answerText = userAnswer;
                }
            }
            const bgClass = isActive ? 'bg-red-50' : (isAnswered ? 'bg-gray-200' : 'bg-white');
            const textClass = isAnswered ? 'text-gray-600' : 'text-gray-800';

            return (
                <button ref={ref} onClick={onClick} className={`w-full border-b border-gray-200 flex items-stretch text-left h-20 transition-colors ${bgClass} ${textClass}`}>
                    <div className={`w-1 shrink-0 ${isActive ? 'bg-red-600' : isBookmarked ? 'bg-red-500' : 'bg-transparent'}`}></div>
                    <div className="flex-1 p-2 relative overflow-hidden h-full grid grid-cols-[1fr_auto] grid-rows-2 gap-x-2">
                        <div className="flex items-center space-x-2 col-start-1 row-start-1 self-start">
                            <span className={`text-2xl font-bold leading-none font-number ${isActive ? 'text-red-600' : isAnswered ? 'text-gray-600' : 'text-gray-800'}`}>{String(q.id).padStart(2, '0')}</span>
                            <span className="text-xs text-gray-400">{q.points}点</span>
                        </div>
                        <div className="col-start-2 row-start-1 row-end-3 w-16 h-full bg-white border border-gray-200 flex items-center justify-center overflow-hidden self-center">
                             <AsyncImage srcs={q.imageSrcs} className="w-full h-full object-cover" />
                        </div>
                        <div className="col-start-1 row-start-2 flex items-end self-end h-full relative w-full overflow-hidden">
                            <div className="flex items-center w-full gap-2">
                                {isBookmarked && <div className="text-red-600 flex-shrink-0"><i className="fas fa-bookmark text-xl"></i></div>}
                                {isAnswered && <span className="text-sm font-bold truncate flex-1 min-w-0 text-left">{answerText}</span>}
                            </div>
                        </div>
                    </div>
                </button>
            );
        });

        // --- Screen Components ---

        const StartScreen = ({ onStart, initialName }) => {
            const [handleName, setHandleName] = useState(initialName || "");
            const [selectedRiddle, setSelectedRiddle] = useState(null);
            const [availableRiddles, setAvailableRiddles] = useState([]);
            const [riddleInfo, setRiddleInfo] = useState({ creator: '...', count: '...', limit: '...' });
            const [isChecking, setIsChecking] = useState(true);

            useEffect(() => {
                const checkRiddles = async () => {
                    const validRiddles = [];
                    const checks = Array.from({ length: MAX_RIDDLE_CHECK }, (_, i) => i + 1).map(async (num) => {
                        try {
                            const csvPath = `riddle/riddle${num}/riddle${num}.csv`;
                            const response = await fetch(csvPath, { method: 'HEAD' }); 
                            if (response.ok) {
                                return num;
                            } else if (response.status === 405) {
                                const responseGet = await fetch(csvPath, { method: 'GET' });
                                if (responseGet.ok) return num;
                            }
                        } catch (e) {}
                        return null;
                    });

                    const results = await Promise.all(checks);
                    const found = results.filter(n => n !== null).sort((a, b) => a - b);
                    setAvailableRiddles(found);
                    if (found.length > 0) {
                        setSelectedRiddle(found[0]);
                    }
                    setIsChecking(false);
                };
                checkRiddles();
            }, []);

            useEffect(() => {
                if (!selectedRiddle) {
                    setRiddleInfo({ creator: '-', count: '-', limit: '-' });
                    return;
                }
                const fetchRiddleInfo = async () => {
                    setRiddleInfo({ creator: '読み込み中...', count: '...', limit: '...' });
                    try {
                        const csvPath = `riddle/riddle${selectedRiddle}/riddle${selectedRiddle}.csv`;
                        const response = await fetch(csvPath);
                        if (!response.ok) throw new Error('Not found');
                        const buffer = await response.arrayBuffer();
                        const decoder = new TextDecoder('utf-8');
                        const text = decoder.decode(buffer);
                        const firstLine = text.split(/\r\n|\n/)[0];
                        if (!firstLine) throw new Error('Empty');
                        const [count, , limit, creator] = firstLine.split(',');
                        setRiddleInfo({
                            count: count ? `${count}問` : '不明',
                            limit: limit ? `${limit}分` : '不明',
                            creator: creator ? creator.trim() : '不明'
                        });
                    } catch (e) {
                        setRiddleInfo({ creator: '不明', count: '不明', limit: '不明' });
                    }
                };
                fetchRiddleInfo();
            }, [selectedRiddle]);

            const onNameChange = (e) => {
                let val = e.target.value;
                val = val.replace(/['";\\<>]/g, '');
                setHandleName(val);
            };

            return (
                <div className="h-full overflow-y-auto relative z-20 custom-scrollbar">
                    <div className="flex flex-col items-center justify-center min-h-full p-4">
                        <div className="max-w-4xl w-full bg-white p-6 md:p-8 space-y-6 md:space-y-8 shadow-xl rounded-lg my-auto">
                            <div className="border-b-2 border-red-600 pb-4 mb-4 md:mb-8 flex justify-between items-end">
                                <div className="h-10 md:h-12"><img src="deco/logo.png" alt="ロゴ" className="h-full object-contain" onError={(e) => e.target.style.display = 'none'} /></div>
                                <div className="text-xs md:text-sm text-gray-500">ユーザーネーム: {handleName || "未入力"}</div>
                            </div>
                            <div className="space-y-4 md:space-y-6">
                                <div className="bg-gray-50 p-4 md:p-6 rounded border border-gray-200">
                                    <label className="block text-gray-700 font-bold mb-2 text-sm md:text-base">ハンドルネーム</label>
                                    <input type="text" className="w-full border-2 border-gray-300 p-2 md:p-3 rounded focus:outline-none focus:border-red-500 text-base md:text-lg" placeholder="ここに入力してください" value={handleName} onChange={onNameChange} maxLength={20} />
                                </div>
                                <div className="bg-gray-50 p-4 md:p-6 rounded border border-gray-200">
                                    <label className="block text-gray-700 font-bold mb-4 text-sm md:text-base">問題セット選択</label>
                                    {isChecking ? (
                                        <div className="text-center py-4 text-gray-500"><i className="fas fa-spinner fa-spin mr-2"></i>問題セットを確認中...</div>
                                    ) : (
                                        <div className="grid grid-cols-2 md:grid-cols-5 gap-3 md:gap-4 mb-4">
                                            {availableRiddles.length > 0 ? (
                                                availableRiddles.map(num => (
                                                    <button 
                                                        key={num} 
                                                        onClick={() => setSelectedRiddle(num)}
                                                        className={`border-2 font-bold py-2 md:py-3 px-2 md:px-4 rounded shadow-sm font-number transition-colors text-sm md:text-base ${selectedRiddle === num ? 'bg-red-600 border-red-600 text-white' : 'bg-red-50 border-red-500 text-red-700'}`}
                                                    >
                                                        riddle{num}
                                                    </button>
                                                ))
                                            ) : (
                                                <div className="col-span-full text-center text-gray-500 py-2">利用可能な問題セットが見つかりません</div>
                                            )}
                                        </div>
                                    )}
                                    <div className="text-sm md:text-base text-gray-700 bg-white p-3 rounded border border-gray-300 flex flex-wrap gap-4 items-center">
                                        <div className="flex items-center"><i className="fas fa-user-edit text-gray-400 mr-2"></i><span className="font-bold mr-1">制作者:</span> {riddleInfo.creator}</div>
                                        <div className="flex items-center"><i className="fas fa-list-ol text-gray-400 mr-2"></i><span className="font-bold mr-1">問題数:</span> {riddleInfo.count}</div>
                                        <div className="flex items-center"><i className="fas fa-stopwatch text-gray-400 mr-2"></i><span className="font-bold mr-1">制限時間:</span> {riddleInfo.limit}</div>
                                    </div>
                                </div>
                            </div>
                            <div className="flex flex-col items-center justify-center mt-8 md:mt-12 space-y-4">
                                <button onClick={() => handleName && selectedRiddle && onStart(handleName, selectedRiddle)} disabled={!handleName || !selectedRiddle} className={`font-bold text-lg md:text-xl py-3 md:py-4 px-8 md:px-12 rounded shadow-lg transition-all ${handleName && selectedRiddle ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-400 text-white cursor-not-allowed'}`}>模試を受ける</button>
                                <div className="text-xs text-gray-500 text-center leading-relaxed">
                                    <p>・このサイトは本家謎検の挙動とは異なることがあります。</p>
                                    <p>・このサイトはSCRAP、および本家謎検とは一切関係ございません。</p>
                                    <p>・ページの再読み込みや「戻る」を行うと、進行状況がリセットされます。</p>
                                    <p>・途中で拡大率を変えないようご注意ください</p>
                                    <p>・推奨環境: Google Chrome / Safari 最新版</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const ExamScreen = ({ userName, onFinish, config, timeLimit }) => {
            const [currentQIndex, setCurrentQIndex] = useState(0);
            const [answers, setAnswers] = useState({});
            const [lockedAnswers, setLockedAnswers] = useState({});
            const [bookmarks, setBookmarks] = useState({});
            const [timeLeft, setTimeLeft] = useState((timeLimit || 60) * 60);
            const [isMenuOpen, setIsMenuOpen] = useState(false);
            const [drawings, setDrawings] = useState({});
            const [redoStack, setRedoStack] = useState({});
            const [tool, setTool] = useState('pencil');
            const [color, setColor] = useState('black');
            const [isToolbarVisible, setIsToolbarVisible] = useState(true);
            const [modalConfig, setModalConfig] = useState({ isOpen: false, message: '', onConfirm: () => {} });
            const [isTimeUp, setIsTimeUp] = useState(false);
            const itemRefs = useRef({});
            const listContainerRef = useRef(null);
            
            const currentQ = config && config.length > 0 ? config[currentQIndex] : null;

            useEffect(() => {
                const timer = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 1) { clearInterval(timer); setIsTimeUp(true); return 0; }
                        return prev - 1;
                    });
                }, 1000);
                return () => clearInterval(timer);
            }, []);

            useEffect(() => {
                if (isTimeUp) {
                    const timeout = setTimeout(() => { onFinish(answers); }, 5000);
                    return () => clearTimeout(timeout);
                }
            }, [isTimeUp, answers, onFinish]);

            useEffect(() => {
                if (!currentQ) return; 
                const element = itemRefs.current[currentQ.id];
                if (element) element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, [currentQIndex, currentQ]);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            };

            const handleAnswerChange = (val) => {
                if (!currentQ || lockedAnswers[currentQ.id]) return;
                setAnswers(prev => ({ ...prev, [currentQ.id]: val }));
            };

            const submitAnswer = () => {
                if (!currentQ) return;
                setLockedAnswers(prev => ({ ...prev, [currentQ.id]: true }));
                setTimeout(() => {
                    if (currentQIndex === config.length - 1) { setCurrentQIndex(0); } 
                    else { setCurrentQIndex(prev => prev + 1); }
                }, 300);
            };

            const resetAnswer = () => {
                if (!currentQ) return;
                setLockedAnswers(prev => { const next = { ...prev }; delete next[currentQ.id]; return next; });
            };
            const toggleBookmark = (id) => setBookmarks(prev => ({ ...prev, [id]: !prev[id] }));
            const navigate = (direction) => {
                if (direction === 'prev' && currentQIndex > 0) setCurrentQIndex(curr => curr - 1);
                if (direction === 'next' && currentQIndex < config.length - 1) setCurrentQIndex(curr => curr + 1);
            };
            const confirmAction = (message, action) => {
                setModalConfig({ isOpen: true, message, onConfirm: () => { action(); setModalConfig(prev => ({ ...prev, isOpen: false })); } });
            };
            const handleFinish = () => onFinish(answers);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    if (e.key === 'ArrowLeft') navigate('prev');
                    if (e.key === 'ArrowRight') navigate('next');
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentQIndex]);

            const handleDrawEnd = useCallback((qId, newStroke) => {
                if (!qId) return;
                setDrawings(prev => {
                    const qDrawings = prev[qId] || [];
                    return { ...prev, [qId]: [...qDrawings, newStroke] };
                });
                setRedoStack(prev => { const next = { ...prev }; delete next[qId]; return next; });
            }, []);

            const undo = () => {
                if (!currentQ) return;
                const qDrawings = drawings[currentQ.id] || [];
                if (qDrawings.length === 0) return;
                const last = qDrawings[qDrawings.length - 1];
                const remaining = qDrawings.slice(0, -1);
                setDrawings(prev => ({ ...prev, [currentQ.id]: remaining }));
                setRedoStack(prev => ({ ...prev, [currentQ.id]: [...(prev[currentQ.id] || []), last] }));
            };

            const redo = () => {
                if (!currentQ) return;
                const qRedos = redoStack[currentQ.id] || [];
                if (qRedos.length === 0) return;
                const toRestore = qRedos[qRedos.length - 1];
                const remaining = qRedos.slice(0, -1);
                setRedoStack(prev => ({ ...prev, [currentQ.id]: remaining }));
                setDrawings(prev => ({ ...prev, [currentQ.id]: [...(prev[currentQ.id] || []), toRestore] }));
            };

            const clearAll = () => { 
                if (!currentQ) return;
                const qDrawings = drawings[currentQ.id] || [];
                if (qDrawings.length === 0 || (qDrawings.length > 0 && qDrawings[qDrawings.length - 1].tool === 'clear')) return;
                const clearStroke = { tool: 'clear', color: 'none', points: [] };
                setDrawings(prev => ({ ...prev, [currentQ.id]: [...qDrawings, clearStroke] }));
                setRedoStack(prev => { const next = {...prev}; delete next[currentQ.id]; return next; }); 
            };

            if (isTimeUp) {
                return (
                    <div className="fixed inset-0 z-50 bg-black/90 flex items-center justify-center flex-col text-white animate-fade-in">
                        <h1 className="text-6xl font-bold mb-4 font-number">TIME UP</h1>
                        <p className="text-2xl">終了しました</p>
                        <p className="mt-8 text-gray-400">解答画面へ移動します...</p>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full font-sans relative z-20 overflow-hidden">
                    <ConfirmationModal isOpen={modalConfig.isOpen} message={modalConfig.message} onConfirm={modalConfig.onConfirm} onCancel={() => setModalConfig(prev => ({ ...prev, isOpen: false }))} />
                    
                    <div className="bg-white border-b border-red-500 h-12 md:h-14 flex items-center justify-between px-2 md:px-4 shrink-0 z-20">
                        <div className="flex items-center space-x-2 md:space-x-4">
                            <div className="h-6 md:h-8"><img src="deco/logo.png" alt="ロゴ" className="h-full object-contain" /></div>
                            <div className="text-xs text-gray-500 hidden md:block">ユーザーネーム: {userName}</div>
                            <button onClick={() => confirmAction('本当に受検を終了しますか？', handleFinish)} className="border border-gray-400 text-gray-700 px-2 py-0.5 md:px-3 md:py-1 text-[10px] md:text-xs hover:bg-gray-100 whitespace-nowrap">受検を終了する &gt;</button>
                        </div>
                        <div className="flex items-end">
                            <span className="text-[10px] md:text-sm text-gray-600 mr-1 mb-1">残り</span>
                            <span className="text-2xl md:text-3xl font-mono text-gray-800 leading-none font-number">{formatTime(timeLeft)}</span>
                        </div>
                    </div>

                    <div className="flex flex-1 overflow-hidden relative">
                        <div className="flex-1 flex flex-col relative z-0 h-full overflow-hidden">
                            <div className="flex-1 flex items-center justify-center p-2 overflow-hidden relative bg-gray-50/50">
                                <div className="w-full h-full max-w-5xl relative flex items-center justify-center">
                                    {currentQIndex > 0 && <button onClick={() => navigate('prev')} className="absolute left-0 top-1/2 -translate-y-1/2 z-30 bg-white/50 hover:bg-white rounded-full p-1 md:p-2 text-gray-600 shadow-lg transform -translate-x-1/2 md:translate-x-0 w-12 h-12 md:w-16 md:h-16 flex items-center justify-center"><i className="fas fa-chevron-left text-2xl md:text-3xl"></i><div className="absolute -bottom-4 text-[10px] md:text-xs text-center font-number bg-white/80 px-1 rounded">{String(currentQIndex).padStart(2,'0')}</div></button>}
                                    {currentQIndex < config.length - 1 && <button onClick={() => navigate('next')} className="absolute right-0 top-1/2 -translate-y-1/2 z-30 bg-white/50 hover:bg-white rounded-full p-1 md:p-2 text-gray-600 shadow-lg transform translate-x-1/2 md:translate-x-0 w-12 h-12 md:w-16 md:h-16 flex items-center justify-center"><i className="fas fa-chevron-right text-2xl md:text-3xl"></i><div className="absolute -bottom-4 text-[10px] md:text-xs text-center font-number bg-white/80 px-1 rounded">{String(currentQIndex + 2).padStart(2,'0')}</div></button>}
                                    
                                    <div className="relative w-full h-full select-none flex items-center justify-center bg-white shadow-lg border border-gray-200">
                                        <AsyncImage srcs={currentQ ? currentQ.imageSrcs : []} alt={`Problem ${currentQ ? currentQ.id : ''}`} className="max-w-full max-h-full object-contain pointer-events-none" fallback={<div className="absolute inset-0 w-full h-full bg-gray-50 flex-col items-center justify-center text-gray-400 border-2 border-dashed border-gray-300 flex"><i className="fas fa-image text-4xl mb-2"></i><span className="text-xl font-bold text-gray-500">問題 {currentQ ? currentQ.id : ''}</span><span className="text-xs mt-2">画像を配置してください</span></div>} />
                                        <div className="absolute inset-0 w-full h-full"><CanvasLayer drawings={drawings[currentQ ? currentQ.id : ''] || []} onDrawEnd={(stroke) => handleDrawEnd(currentQ ? currentQ.id : null, stroke)} tool={tool} color={color} isVisible={isToolbarVisible} /></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="bg-white border-t border-gray-300 p-2 shrink-0 z-20 shadow-[0_-2px_10px_rgba(0,0,0,0.1)]">
                                <div className="flex justify-center items-center mb-2 bg-gray-100 py-1 px-2 rounded-lg inline-block mx-auto min-w-max max-w-full overflow-x-auto custom-scrollbar">
                                    <button onClick={() => setIsToolbarVisible(!isToolbarVisible)} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200 ${isToolbarVisible ? 'text-red-600' : ''}`}><i className={`fas ${isToolbarVisible ? 'fa-eye' : 'fa-eye-slash'} text-sm md:text-lg`}></i></button>
                                    <div className={`flex items-center space-x-1 md:space-x-2 ${isToolbarVisible ? '' : 'invisible pointer-events-none'}`}>
                                        <div className="w-px h-5 md:h-6 bg-gray-300 mx-1"></div>
                                        <button onClick={() => setTool('pencil')} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border ${tool==='pencil' ? 'border-red-500 bg-red-50 text-red-600' : 'border-transparent text-gray-600 hover:bg-gray-200'}`}><i className="fas fa-pencil-alt text-sm md:text-lg"></i></button>
                                        <button onClick={() => setTool('line')} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border ${tool==='line' ? 'border-red-500 bg-red-50 text-red-600' : 'border-transparent text-gray-600 hover:bg-gray-200'}`}><i className="fas fa-slash text-sm md:text-lg"></i></button>
                                        <button onClick={() => setTool('eraser')} className={`w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border ${tool==='eraser' ? 'border-red-500 bg-red-50 text-red-600' : 'border-transparent text-gray-600 hover:bg-gray-200'}`}><i className="fas fa-eraser text-sm md:text-lg"></i></button>
                                        <div className="w-px h-5 md:h-6 bg-gray-300 mx-1"></div>
                                        <button onClick={() => setColor('black')} className={`w-6 h-6 md:w-8 md:h-8 rounded-full border-2 mx-0.5 md:mx-1 flex items-center justify-center ${color==='black' ? 'border-red-500 scale-110' : 'border-transparent opacity-70 hover:opacity-100'}`}><div className="w-full h-full rounded-full border border-gray-300 bg-black"></div></button>
                                        <button onClick={() => setColor('red')} className={`w-6 h-6 md:w-8 md:h-8 rounded-full border-2 mx-0.5 md:mx-1 flex items-center justify-center ${color==='red' ? 'border-red-500 scale-110' : 'border-transparent opacity-70 hover:opacity-100'}`}><div className="w-full h-full rounded-full border border-gray-300 bg-red-600"></div></button>
                                        <button onClick={() => setColor('blue')} className={`w-6 h-6 md:w-8 md:h-8 rounded-full border-2 mx-0.5 md:mx-1 flex items-center justify-center ${color==='blue' ? 'border-red-500 scale-110' : 'border-transparent opacity-70 hover:opacity-100'}`}><div className="w-full h-full rounded-full border border-gray-300 bg-blue-600"></div></button>
                                        <div className="w-px h-5 md:h-6 bg-gray-300 mx-1"></div>
                                        <button onClick={undo} className="w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200"><i className="fas fa-undo text-sm md:text-lg"></i></button>
                                        <button onClick={redo} className="w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200"><i className="fas fa-redo text-sm md:text-lg"></i></button>
                                        <button onClick={clearAll} className="w-8 h-8 md:w-10 md:h-10 flex items-center justify-center rounded border border-transparent text-gray-600 hover:bg-gray-200"><i className="fas fa-trash-alt text-sm md:text-lg"></i></button>
                                    </div>
                                </div>
                                
                                <div className="flex flex-row items-stretch space-x-2 max-w-4xl mx-auto h-12 md:h-14">
                                    <button onClick={() => currentQ && toggleBookmark(currentQ.id)} className={`flex flex-col items-center justify-center px-1 md:p-2 w-10 md:w-14 shrink-0 ${currentQ && bookmarks[currentQ.id] ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'} transition-colors rounded-sm`}>
                                        <div className="text-[8px] md:text-[9px] mb-0.5 whitespace-nowrap">後で確認</div>
                                        <i className={`fas fa-bookmark text-sm md:text-xl ${currentQ && bookmarks[currentQ.id] ? 'text-white' : 'text-gray-400'}`}></i>
                                    </button>
                                    
                                    <div className="flex-1 border-2 border-black flex items-center px-2 md:px-4 relative bg-gray-100 overflow-hidden">
                                        {currentQ && currentQ.type === 'text' ? (
                                            <input type="text" placeholder={currentQ && lockedAnswers[currentQ.id] ? "" : "解答入力"} value={currentQ ? answers[currentQ.id] || "" : ""} onChange={(e) => handleAnswerChange(e.target.value)} disabled={currentQ && lockedAnswers[currentQ.id]} className="w-full h-full bg-transparent text-lg md:text-xl outline-none disabled:text-gray-500" />
                                        ) : (
                                            <div className="flex space-x-2 md:space-x-4 w-full h-full items-center overflow-x-auto no-scrollbar">
                                                {currentQ && currentQ.options.map((opt, idx) => (
                                                    <button key={idx} disabled={currentQ && lockedAnswers[currentQ.id]} onClick={() => handleAnswerChange(idx)} className={`flex items-center space-x-1 px-1.5 py-1 rounded whitespace-nowrap ${currentQ && answers[currentQ.id] === idx ? 'text-red-600 font-bold' : 'text-gray-600'}`}>
                                                        <span className={`w-3 h-3 md:w-4 md:h-4 rounded-full border flex-shrink-0 ${currentQ && answers[currentQ.id] === idx ? 'bg-red-600 border-red-600' : 'border-gray-400'}`}></span>
                                                        <span className="text-sm md:text-base">{getCircledNumber(idx)} {opt}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    
                                    <div className="w-20 md:w-32 shrink-0">
                                        {currentQ && lockedAnswers[currentQ.id] ? (
                                            <button onClick={resetAnswer} className="w-full h-full border-2 border-red-600 text-red-600 font-bold hover:bg-red-50 text-sm md:text-lg">リセット</button>
                                        ) : (
                                            <button onClick={submitAnswer} className="w-full h-full border-2 border-red-800 text-red-800 font-bold bg-white hover:bg-red-50 text-sm md:text-lg shadow-sm">解答</button>
                                        )}
                                    </div>
                                </div>
                                <div className="md:hidden mt-1 text-center">
                                    <button onClick={() => setIsMenuOpen(true)} className="text-[10px] font-bold flex items-center justify-center w-full py-1 bg-white border shadow-sm text-gray-500"><i className="fas fa-list-ol mr-1"></i> 問題一覧を見る</button>
                                </div>
                            </div>
                        </div>

                        <div className="hidden md:flex w-64 bg-white border-l border-gray-300 flex-col shrink-0 overflow-hidden h-full">
                            <div ref={listContainerRef} className="flex-1 overflow-y-auto custom-scrollbar pb-20">
                                {config.map((q, idx) => (
                                    <QuestionListItem key={q.id} ref={(el) => itemRefs.current[q.id] = el} q={q} isActive={currentQIndex === idx} isAnswered={!!lockedAnswers[q.id]} isBookmarked={!!bookmarks[q.id]} userAnswer={answers[q.id]} onClick={() => setCurrentQIndex(idx)} />
                                ))}
                            </div>
                        </div>
                    </div>
                    
                    {isMenuOpen && (
                        <div className="fixed inset-0 z-50 bg-gray-800/80 flex items-center justify-center p-4">
                            <div className="bg-white w-full h-full max-w-md rounded-lg overflow-hidden flex flex-col relative">
                                <div className="p-4 border-b flex justify-between items-center bg-gray-100">
                                    <span className="font-bold">問題一覧</span>
                                    <button onClick={() => setIsMenuOpen(false)}><i className="fas fa-times text-2xl text-gray-600"></i></button>
                                </div>
                                <div className="flex-1 overflow-y-auto p-2">
                                    {config.map((q, idx) => (
                                        <QuestionListItem key={q.id} q={q} isActive={currentQIndex === idx} isAnswered={!!lockedAnswers[q.id]} isBookmarked={!!bookmarks[q.id]} userAnswer={answers[q.id]} onClick={() => { setCurrentQIndex(idx); setIsMenuOpen(false); }} />
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const FinishScreen = ({ userAnswers, onRestart, config, riddleId, userName }) => {
            // modalState: { index: number, type: 'image' | 'explanation' } or null
            const [modalState, setModalState] = useState(null);
            
            const results = useMemo(() => {
                let totalScore = 0;
                let maxScore = 0; 
                
                const grading = config.map(q => {
                    maxScore += q.points;
                    const userAns = userAnswers[q.id];
                    let isCorrect = false;
                    let displayUserAns = "-";
                    let displayCorrectAns = "-";
                    
                    if (q.type === 'choice') {
                        if (userAns !== undefined) {
                            displayUserAns = `${getCircledNumber(userAns)}${q.options[userAns]}`;
                        } else {
                            displayUserAns = "未回答";
                        }
                        const correctStr = q.primaryAnswer || ""; 
                        const hasCircle = /^[\u2460-\u2469]/.test(correctStr);
                        if (hasCircle) {
                            displayCorrectAns = correctStr;
                        } else {
                            const correctIndex = q.options.findIndex(opt => opt === correctStr);
                            if (correctIndex !== -1) {
                                displayCorrectAns = `${getCircledNumber(correctIndex)}${q.options[correctIndex]}`;
                            } else {
                                displayCorrectAns = correctStr;
                            }
                        }
                        const userAnsText = userAns !== undefined ? q.options[userAns] : "";
                        const userAnsFull = userAns !== undefined ? `${getCircledNumber(userAns)}${q.options[userAns]}` : "";
                        isCorrect = q.correctAnswerList.some(ans => ans === userAnsText || ans === userAnsFull);
                    } else {
                        displayUserAns = userAns || "未回答";
                        displayCorrectAns = q.primaryAnswer || "";
                        isCorrect = q.correctAnswerList.includes(userAns);
                    }

                    if (isCorrect) totalScore += q.points;
                    return { 
                        id: q.id, 
                        userAns: displayUserAns, 
                        correctAns: displayCorrectAns, 
                        isCorrect, 
                        explanationSrcs: q.explanationSrcs,
                        imageSrcs: q.imageSrcs 
                    };
                });
                return { grading, totalScore, maxScore };
            }, [userAnswers, config]);

            const getGrade = (score) => {
                if (score >= 100) return "1級";
                if (score >= 90) return "準1級";
                if (score >= 80) return "2級";
                if (score >= 70) return "準2級";
                if (score >= 60) return "3級";
                if (score >= 50) return "4級";
                if (score >= 40) return "5級";
                if (score >= 30) return "6級";
                if (score >= 20) return "7級";
                return "8級";
            };

            const shareOnX = () => {
                const text = `riddle${riddleId}で${results.totalScore}点を獲得しました！判定は${getGrade(results.totalScore)}です！\nあなたも謎を解いてみよう\nhttps://maruten0420.github.io/Nazoken-Modoki/`;
                const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
                window.open(url, '_blank');
            };

            // Modal Controls
            const openModal = (index, type) => {
                setModalState({ index, type });
            };
            const closeModal = () => setModalState(null);
            
            const goPrev = () => {
                if (modalState) {
                    const newIndex = modalState.index > 0 ? modalState.index - 1 : results.grading.length - 1;
                    setModalState({ ...modalState, index: newIndex });
                }
            };
            const goNext = () => {
                if (modalState) {
                    const newIndex = modalState.index < results.grading.length - 1 ? modalState.index + 1 : 0;
                    setModalState({ ...modalState, index: newIndex });
                }
            };
            const toggleType = () => {
                if (modalState) {
                    setModalState({ 
                        ...modalState, 
                        type: modalState.type === 'image' ? 'explanation' : 'image' 
                    });
                }
            };

            const currentModalData = modalState ? results.grading[modalState.index] : null;
            const currentModalSrcs = modalState 
                ? (modalState.type === 'image' ? currentModalData.imageSrcs : currentModalData.explanationSrcs)
                : null;
            
            // 修正: 問題か解説かでモードを切り替える
            const isScrollMode = modalState && modalState.type === 'explanation';

            return (
                <div className="flex flex-col h-full font-sans overflow-hidden relative z-20">
                     <div className="bg-white border-b border-red-500 h-12 md:h-14 flex items-center justify-between px-2 md:px-4 shrink-0 z-20">
                        <div className="flex items-center space-x-2 md:space-x-4">
                            <div className="h-6 md:h-8"><img src="deco/logo.png" alt="ロゴ" className="h-full object-contain" /></div>
                            <div className="text-xs text-gray-500 hidden md:block">ユーザーネーム: {userName}</div>
                        </div>
                    </div>

                     <div className="border-b-4 border-red-600 p-4 bg-white shrink-0 shadow-sm text-center flex flex-row justify-center items-center gap-4">
                        <div className="text-3xl md:text-4xl font-bold text-gray-800">
                            判定: <span className="text-red-600">{getGrade(results.totalScore)}</span>
                        </div>
                        <div className="w-[2px] h-8 bg-gray-300 mx-2"></div>
                        <div className="text-xl md:text-2xl font-bold text-gray-600 font-number">
                            点数: {results.totalScore}点 / {results.maxScore}点
                        </div>
                    </div>
                    
                    <div className="flex-1 overflow-y-auto p-2 md:p-8">
                        <div className="max-w-5xl mx-auto bg-white shadow rounded-lg overflow-hidden">
                            <table className="w-full text-left border-collapse text-sm md:text-base">
                                <thead className="bg-gray-100 border-b border-gray-300">
                                    <tr>
                                        <th className="p-2 md:p-3 text-center w-10 md:w-16">No.</th>
                                        <th className="p-2 md:p-3 w-1/4">正解</th>
                                        <th className="p-2 md:p-3 w-1/4">あなたの答え</th>
                                        <th className="p-2 md:p-3 text-center w-10 md:w-16">判定</th>
                                        <th className="p-2 md:p-3 text-center w-20 md:w-24">問題</th>
                                        <th className="p-2 md:p-3 text-center w-16 md:w-24">解説</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {results.grading.map((row, idx) => (
                                        <tr key={row.id} className="border-b border-gray-200 hover:bg-gray-50">
                                            <td className="p-2 md:p-3 text-center font-bold text-gray-700 font-number">{row.id}</td>
                                            <td className="p-2 md:p-3 text-green-700 font-medium break-all">{row.correctAns}</td>
                                            <td className="p-2 md:p-3 text-gray-800 break-all">{row.userAns}</td>
                                            <td className="p-2 md:p-3 text-center">
                                                {row.isCorrect ? <i className="fas fa-check-circle text-green-500 text-xl md:text-2xl"></i> : <i className="fas fa-times-circle text-red-500 text-xl md:text-2xl"></i>}
                                            </td>
                                            <td className="p-2 md:p-3 text-center">
                                                <button onClick={() => openModal(idx, 'image')} className="text-gray-600 hover:text-blue-600 transition-colors flex items-center justify-center w-full">
                                                    <i className="far fa-image text-xl mr-1"></i>
                                                    <span className="text-xs font-bold">問題</span>
                                                </button>
                                            </td>
                                            <td className="p-2 md:p-3 text-center">
                                                <button onClick={() => openModal(idx, 'explanation')} className="text-gray-600 hover:text-red-600 transition-colors flex items-center justify-center w-full">
                                                    <i className="fas fa-book-open text-xl mr-1"></i>
                                                    <span className="text-xs font-bold">解説</span>
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="flex flex-col items-center justify-center mt-8 pb-8 space-y-4">
                             <button onClick={onRestart} className="bg-red-600 text-white font-bold text-lg py-4 px-12 hover:bg-red-700 shadow-lg transition-colors">トップページに戻る</button>
                             <button onClick={shareOnX} className="bg-black text-white font-bold text-lg py-3 px-10 rounded-full hover:bg-gray-800 shadow-lg transition-colors flex items-center">
                                <i className="fab fa-x-twitter mr-2 text-xl"></i> 𝕏で結果報告！
                             </button>
                        </div>
                    </div>
                    
                    {modalState && (
                        <div className="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4 animate-fade-in" onClick={closeModal}>
                            <div className="relative w-full max-w-5xl h-full flex flex-col pointer-events-none">
                                {/* Close Button */}
                                <div className="flex justify-end p-2 pointer-events-auto">
                                    <button onClick={closeModal} className="text-white hover:text-gray-300">
                                        <i className="fas fa-times text-3xl"></i>
                                    </button>
                                </div>

                                {/* Main Content */}
                                <div 
                                    className={`flex-1 relative pointer-events-auto bg-white rounded-lg mb-2 ${isScrollMode ? 'overflow-y-auto custom-scrollbar' : 'overflow-hidden flex items-center justify-center'}`} 
                                    onClick={e => e.stopPropagation()}
                                >
                                    <AsyncImage 
                                        srcs={currentModalSrcs} 
                                        alt="詳細" 
                                        className={isScrollMode ? "w-full h-auto block" : "max-w-full max-h-full object-contain"} 
                                        mode={isScrollMode ? 'scroll' : 'fit'}
                                        fallback={<div className="text-gray-500 p-4 text-center">画像が見つかりません</div>} 
                                    />
                                </div>

                                {/* Navigation Bar */}
                                <div className="bg-white rounded-full p-2 flex items-center justify-between pointer-events-auto shadow-lg select-none" onClick={e => e.stopPropagation()}>
                                    <button 
                                        onClick={goPrev} 
                                        className={`w-12 h-12 flex items-center justify-center rounded-full transition-colors text-gray-700 hover:bg-gray-100 active:bg-gray-200`}
                                    >
                                        <i className="fas fa-chevron-left text-2xl"></i>
                                    </button>

                                    <div className="flex flex-col items-center">
                                        <div className="text-sm font-bold text-gray-500 mb-1">
                                            No.{currentModalData.id}
                                        </div>
                                        <button 
                                            onClick={toggleType}
                                            className={`px-6 py-2 rounded-full font-bold text-white shadow transition-transform active:scale-95 flex items-center ${modalState.type === 'image' ? 'bg-red-600 hover:bg-red-700' : 'bg-blue-600 hover:bg-blue-700'}`}
                                        >
                                            {modalState.type === 'image' ? (
                                                <><i className="fas fa-book-open mr-2"></i>解説を見る</>
                                            ) : (
                                                <><i className="far fa-image mr-2"></i>問題を見る</>
                                            )}
                                        </button>
                                    </div>

                                    <button 
                                        onClick={goNext} 
                                        className={`w-12 h-12 flex items-center justify-center rounded-full transition-colors text-gray-700 hover:bg-gray-100 active:bg-gray-200`}
                                    >
                                        <i className="fas fa-chevron-right text-2xl"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const App = () => {
            const [screen, setScreen] = useState('start');
            const [userName, setUserName] = useState("");
            const [finalAnswers, setFinalAnswers] = useState({});
            const [config, setConfig] = useState([]);
            const [loading, setLoading] = useState(false);
            const viewportHeight = useViewportHeight();
            const [timeLimit, setTimeLimit] = useState(60);
            const [currentRiddleId, setCurrentRiddleId] = useState(1);

            const loadRiddleData = async (riddleId) => {
                setLoading(true);
                try {
                    const csvPath = `riddle/riddle${riddleId}/riddle${riddleId}.csv`;
                    const response = await fetch(csvPath);
                    if (!response.ok) throw new Error('CSV not found');
                    const buffer = await response.arrayBuffer();
                    const decoder = new TextDecoder('utf-8');
                    const text = decoder.decode(buffer);
                    const lines = text.split(/\r\n|\n/).filter(line => line.trim() !== '');
                    if (lines.length < 1) throw new Error('Empty CSV');

                    const headCols = lines[0].split(',');
                    const totalStr = headCols[0] || '0';
                    const selCountStr = headCols[1] || '0';
                    const timeLimitStr = headCols[2] || '';
                    const totalQuestions = parseInt(totalStr, 10) || 0;
                    const selectionCount = parseInt(selCountStr, 10) || 0;
                    const parsedLimit = parseInt(timeLimitStr, 10);
                    setTimeLimit(!isNaN(parsedLimit) && parsedLimit > 0 ? parsedLimit : 60);

                    const selectionMap = {};
                    for (let i = 1; i <= selectionCount; i++) {
                        if (i >= lines.length) break;
                        const cols = lines[i] ? lines[i].split(',') : [];
                        const qId = parseInt(cols[0], 10);
                        if (isNaN(qId)) continue;
                        const options = cols.slice(1).filter(opt => opt && opt.trim() !== '');
                        selectionMap[qId] = options;
                    }

                    const tempConfig = [];
                    const startAnswerLine = selectionCount + 1;
                    
                    for (let i = 0; i < totalQuestions; i++) {
                        const lineIdx = startAnswerLine + i;
                        if (lineIdx >= lines.length) break;
                        const cols = lines[lineIdx] ? lines[lineIdx].split(',') : [];
                        const points = parseInt(cols[0], 10) || 0;
                        const validAnswers = cols.slice(1).filter(a => a && a.trim() !== '');
                        const primaryAnswer = cols[1] ? cols[1].trim() : ""; 
                        const qId = i + 1;
                        const isSelection = !!selectionMap[qId];
                        const qNum = String(qId).padStart(2, '0');
                        const imgBase = `riddle/riddle${riddleId}/riddle${riddleId}_${qNum}`;
                        const ansBase = `riddle/riddle${riddleId}/answer_${qNum}`;
                        const imageSrcs = FILE_EXTENSIONS.map(ext => imgBase + ext);
                        const explanationSrcs = FILE_EXTENSIONS.map(ext => ansBase + ext);
                        tempConfig.push({
                            id: qId,
                            imageSrcs: imageSrcs,
                            explanationSrcs: explanationSrcs,
                            points: points,
                            type: isSelection ? 'choice' : 'text',
                            options: selectionMap[qId] || [],
                            correctAnswerList: validAnswers,
                            primaryAnswer: primaryAnswer
                        });
                    }

                    // --- PRELOAD LOGIC START ---
                    // Resolve valid image URLs for all questions BEFORE starting exam
                    const preloadPromises = tempConfig.map(q => resolveImage(q.imageSrcs));
                    const resolvedSrcs = await Promise.all(preloadPromises);

                    // Update config with the specifically resolved URL (if found) to avoid AsyncImage flickering/retrying
                    resolvedSrcs.forEach((src, idx) => {
                        if (src) {
                            tempConfig[idx].imageSrcs = [src]; 
                        }
                    });
                    // --- PRELOAD LOGIC END ---

                    setConfig(tempConfig);
                    setScreen('exam'); 
                } catch (e) {
                    console.error("CSV Load Error:", e);
                    alert(`データの読み込みに失敗しました。\n${e.message}`);
                } finally {
                    setLoading(false);
                }
            };

            const startExam = (name, riddleId) => {
                setUserName(name);
                setCurrentRiddleId(riddleId); 
                loadRiddleData(riddleId);
            };

            const finishExam = (answers) => { setFinalAnswers(answers); setScreen('finish'); };
            const restart = () => { setFinalAnswers({}); setScreen('start'); };

            if (loading) {
                return <div className="w-full flex items-center justify-center bg-white font-sans text-xl font-bold flex-col" style={{ height: viewportHeight }}>
                    <div className="mb-4"><i className="fas fa-spinner fa-spin text-4xl text-red-600"></i></div>
                    <div>試験データを準備中...</div>
                    <div className="text-sm text-gray-500 mt-2 font-normal">画像の読み込みを行っています</div>
                </div>;
            }

            return (
                <div className="w-full font-sans border-[4px] md:border-[8px] border-red-600 box-border overflow-hidden relative" style={{ height: viewportHeight }}>
                    <div style={{ position: 'absolute', inset: 0, zIndex: -1, backgroundImage: "url('deco/back.png')", backgroundRepeat: 'repeat', backgroundPosition: 'center', opacity: 0.5 }}></div>
                    {screen === 'start' && <StartScreen onStart={startExam} initialName={userName} />}
                    {screen === 'exam' && <ExamScreen userName={userName} onFinish={finishExam} config={config} timeLimit={timeLimit} />}
                    {screen === 'finish' && <FinishScreen userAnswers={finalAnswers} onRestart={restart} config={config} riddleId={currentRiddleId} userName={userName} />}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
